{"version":3,"sources":["../../src/strategies/linearRegression.js"],"names":["gradientDescent","getPredictedRatings","computeCost","LEARNING_RATE","LEARNING_ITERATIONS","predictWithLinearRegression","X","MOVIES_IN_LIST","ratings","ones","Array","length","fill","map","v","i","concat","init","training","y","test","references","reduce","result","movie","key","hasRatedMovie","id","push","rating","m","theta","predictedRatings","score","movieId","ALPHA","ITERATIONS","eval","cost","console","log","predictions","sqrErrors","J"],"mappings":"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","file":"linearRegression.js","sourcesContent":["import math from 'mathjs';\r\n\r\nimport { sortByScore } from './common';\r\n\r\nconst LEARNING_RATE = 0.03;\r\nconst LEARNING_ITERATIONS = 750;\r\n\r\nfunction predictWithLinearRegression(X, MOVIES_IN_LIST, ratings) {\r\n  // Add intercept term\r\n  const ones = Array(X.length).fill().map((v, i) => [1]);\r\n  X = math.concat(ones, X);\r\n\r\n  const init = {\r\n    training: {\r\n      X: [],\r\n      y: [],\r\n    },\r\n    // Not a real test set\r\n    // Because of missing labels\r\n    test: {\r\n      X: [],\r\n      references: [],\r\n    }\r\n  };\r\n\r\n  // Prepare training and test set\r\n  const { training, test } = MOVIES_IN_LIST.reduce((result, movie, key) => {\r\n    const hasRatedMovie = !!ratings[movie.id];\r\n    if (hasRatedMovie) {\r\n      result.training.X.push(X[key]);\r\n      result.training.y.push([ratings[movie.id].rating]);\r\n    } else {\r\n      result.test.X.push(X[key]);\r\n      // Keep a reference to map the predictions later to movies\r\n      result.test.references.push(movie.id);\r\n    }\r\n\r\n    return result;\r\n  }, init);\r\n\r\n  // Train theta paramaters\r\n  let m = training.X[0].length;\r\n  let theta = Array(m).fill().map((v, i) => [0]);\r\n  theta = gradientDescent(\r\n    training.X,\r\n    training.y,\r\n    theta,\r\n    LEARNING_RATE,\r\n    LEARNING_ITERATIONS\r\n  );\r\n\r\n  // Predict all ratings\r\n  let predictedRatings = getPredictedRatings(theta, test.X);\r\n\r\n  // Enrich the vector to convey all information\r\n  // Use references from before which we kept track of\r\n  predictedRatings = predictedRatings.map((rating, key) => ({\r\n    score: rating[0],\r\n    movieId: test.references[key],\r\n  }));\r\n\r\n  return sortByScore(predictedRatings);\r\n}\r\n\r\nexport function gradientDescent(X, y, theta, ALPHA, ITERATIONS) {\r\n  const m = y.length;\r\n\r\n  for (let i = 0; i < ITERATIONS; i++) {\r\n    theta = math.eval(`theta - ALPHA / m * ((X * theta - y)' * X)'`, {\r\n      theta,\r\n      ALPHA,\r\n      m,\r\n      X,\r\n      y,\r\n    });\r\n\r\n    if (i % 50 === 0) {\r\n      const cost = computeCost(X, y, theta);\r\n      console.log(`Cost after ${i} of trained ${ITERATIONS}: ${cost}`);\r\n    }\r\n  }\r\n  console.log(`\\n`);\r\n\r\n  return theta;\r\n}\r\n\r\nexport function getPredictedRatings(theta, X) {\r\n  return math.eval(`X * theta`, {\r\n    theta,\r\n    X,\r\n  })\r\n}\r\n\r\nexport function computeCost(X, y, theta) {\r\n  let m = y.length;\r\n\r\n  let predictions = math.eval('X * theta', {\r\n    X,\r\n    theta,\r\n  });\r\n\r\n  let sqrErrors = math.eval('(predictions - y).^2', {\r\n    predictions,\r\n    y,\r\n  });\r\n\r\n  let J = math.eval(`1 / (2 * m) * sum(sqrErrors)`, {\r\n    m,\r\n    sqrErrors,\r\n  });\r\n\r\n  return J;\r\n}\r\n\r\nexport default predictWithLinearRegression;"]}